# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Blz7htqW8ntfM6fwY_StQvYfqZP0x6k
"""



import streamlit as st
import pandas as pd
import numpy as np
from medpy.io import load
from pathlib import Path
import matplotlib.pyplot as plt
import torch
import torchvision
import pickle
import tempfile
import io
import torch.nn as nn

class UNet(nn.Module):
    def __init__(self, n_channels, n_classes, bilinear=True):
        super(UNet, self).__init__()
        self.n_channels = n_channels
        self.n_classes = n_classes
        self.bilinear = bilinear
        
        self.inc = DoubleConv(n_channels, 64)
        self.down1 = Down(64, 128)
        self.down2 = Down(128, 256)
        self.down3 = Down(256, 512)
        factor = 2 if bilinear else 1
        self.down4 = Down(512, 1024//factor)

        self.up1 = Up(1024, 512//factor, bilinear)
        self.up2 = Up(512, 256//factor, bilinear)        
        self.up3 = Up(256, 128//factor, bilinear)        
        self.up4 = Up(128, 64, bilinear)        
        self.outc = OutConv(64, n_classes)

        self.linear =  nn.Sequential(nn.MaxPool2d(kernel_size=(2,2), stride=(2,2)), 
                                     nn.Flatten(),
                                     nn.Linear(4608, 2000),
                                     nn.ReLU(),
                                     nn.Linear(2000, 1000),
                                     nn.ReLU(),
                                     nn.Linear(1000,6)
                                     )
    
    def forward(self, x):
        x1 = self.inc(x)
        x2 = self.down1(x1)
        x3 = self.down2(x2)
        x4 = self.down3(x3)
        x5 = self.down4(x4)
        out = self.linear(x5)
        x = self.up1(x5, x4)
        x = self.up2(x, x3)
        x = self.up3(x, x2)
        x = self.up4(x, x1)
        logits = self.outc(x)
        return logits, out


import torch.nn.functional as F
class DoubleConv(nn.Module):
    """(convolution => [BN] => ReLU) * 2"""
    def __init__(self, in_channels, out_channels, mid_channels=None):
        super().__init__()
        if not mid_channels:
            mid_channels = out_channels
        self.double_conv = nn.Sequential(
            nn.Conv2d(in_channels, mid_channels, kernel_size=3, padding=1),
            nn.BatchNorm2d(mid_channels),
            nn.ReLU(inplace=True),
            nn.Conv2d(mid_channels, out_channels, kernel_size=3, padding=1),
            nn.BatchNorm2d(out_channels),
            nn.ReLU(inplace=True))
    def forward(self, x):
        return self.double_conv(x)
    
class Down(nn.Module):
    """Downscaling with maxpool then double conv"""
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.maxpool_conv = nn.Sequential(
            nn.MaxPool2d(2),
            DoubleConv(in_channels, out_channels))
    def forward(self, x):
        return self.maxpool_conv(x)
    
class Up(nn.Module):
    """Upscaling then double conv"""
    def __init__(self, in_channels, out_channels, bilinear=True):
        super().__init__()
        if bilinear:
            self.up = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
            self.conv = DoubleConv(in_channels, out_channels, in_channels//2)
        else:
            self.up = nn.ConvTranspose2d(in_channels, in_channels//2, kernel_size=2, stride=2)
            self.conv = DoubleConv(in_channels, out_channels)
    def forward(self, x1, x2):
        x1 = self.up(x1)
        diffY = x2.size()[2] - x1.size()[2]
        diffX = x2.size()[3] - x1.size()[3]
        
        x1 = F.pad(x1, [diffX//2, diffX-diffX//2,
                        diffY//2, diffY-diffY//2])
        x = torch.cat([x2, x1], dim=1)
        return self.conv(x)

class OutConv(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(OutConv, self).__init__()
        self.conv = nn.Sequential(
            nn.Conv2d(in_channels, out_channels, kernel_size=1),
            nn.Sigmoid())
    def forward(self, x):
        return self.conv(x)



class CPU_Unpickler(pickle.Unpickler):
    def find_class(self, module, name):
        if module == 'torch.storage' and name == '_load_from_bytes':
            return lambda b: torch.load(io.BytesIO(b), map_location='cpu')
        else:
            return super().find_class(module, name)

app_mode = st.sidebar.selectbox('Select Page',['Home','Give_Predictions'])
if app_mode=='Home': 
  st.title('Cancer something') 
  st.markdown('Dataset taken from the PI-CAI')

elif app_mode == 'Give_Predictions':
  st.subheader('Give image as a medpy supported file (e.g. .mha) :')
  FILE = st.file_uploader("FILE")
  
  with tempfile.NamedTemporaryFile(suffix = ".mha",delete=False) as tmp_file:
    if st.button("Predict"):
      fp = Path(tmp_file.name)
      fp.write_bytes(FILE.getvalue())
      image, header = load(fp.absolute())
      image = torch.from_numpy(image.transpose(2,0,1).astype(np.int16))		

      resizer = torchvision.transforms.Resize((104,104), antialias=False)
      resizer1 = torchvision.transforms.Resize((50,104), antialias=False)
      
      image = resizer(image)
      image = resizer1(image.permute(1,0,2)).permute(1,0,2).reshape(1,50,104,104)
      image = image.permute(1,0,2,3)
      
      model = UNet(1,1)

      picklefile = open("model.pkl", "rb")
     
      model = pickle.load(picklefile)

      img, prediction = model(image.float())
      
      fig, x = plt.subplots()

      x.imshow(img[25][0].detach().numpy(),cmap = "gray")

      st.caption("Label : ")
      st.caption(torch.argmax(prediction[25]).item())
      st.pyplot(fig)


